
==================== FINAL INTERFACE ====================
2018-03-09 08:12:08.095017 UTC

interface CripH_6c6QSyYgErH80S6dnRE85H:Afin 7103
  interface hash: 60c9732ad1a998ba922d168d529fd722
  ABI hash: 6c53daed12fdcf609df571d305b4184d
  export-list hash: cfc1907094e7a59643297b0b4429b5b3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4c0a7b65a6dddbc4161c2e2bfabe3dc3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Afin.afinF
  Afin.afinG
  Afin.desencriptaAfin
  Afin.despejak1
  Afin.letrasFrecuentes
  Afin.mensajeYclaveA
  Afin.mensajeYclaveOK
  Afin.posibleClave
  Afin.primocon26
  Afin.prop_CorreccionAfin
module dependencies: Asociacion1 Criptoanalisis Generadores
package dependencies: QuickCheck-2.8.2@Quick_6TxL5Cx3o2p0HsyT59KWiD
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0*
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC
                      primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      random-1.1@rando_9Kgekc9yEaLHLNUuw6paWL template-haskell-2.10.0.0
                      tf-random-0.5@tfran_1eLmkn3WUnC8NZpPuDLGKF
                      time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Format.Parse
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
import  -/  Asociacion1 7b26843ace7bd8fe186746353ab290d2
  exports: 7db8fe3eaac51f331a6e6dfa0abc57b4
  enAbecedario fefff0427a5d7e1a57ea51fc5c3fd393
  int2str f1e369e1daaa5830458c6378c6512fb2
  invMod 14e1f8cf20f1ac77170e676768762b34
  str2int 23f590a1111fd984fc0822842485dd88
import  -/  Criptoanalisis 2f5377d24f73a09ab5faed7909e61d4a
  exports: b3d8e1179e155833514019d4eeffcdad
  frecuencias 5f1cdbb5bfcafc553ef61ddb826e4057
  ordena2 16f9bdf3c177e36c0e5f9266c6bdfc47
import  -/  Generadores 2defa8c3b976da9db3197c8db2d45db5
  exports: 9c24a9f6675b7e81b0dcac4f05a0c3f6
  mensaje 8f7d4b319dbe775ba6d0b67a6457a491
import  -/  QuickCheck-2.8.2@Quick_6TxL5Cx3o2p0HsyT59KWiD:Test.QuickCheck 7e615a40a74c9052467718d8c88a3cda
import  -/  QuickCheck-2.8.2@Quick_6TxL5Cx3o2p0HsyT59KWiD:Test.QuickCheck.Gen 06f68a423d098fdb51859fed401c5be6
import  -/  QuickCheck-2.8.2@Quick_6TxL5Cx3o2p0HsyT59KWiD:Test.QuickCheck.Property 2d09f2ef07ce3d8d7d5d68d4a6d952e3
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
772273a42314382c211f78ced5d7e267
  $wa ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> (# GHC.Base.String, (GHC.Types.Int, GHC.Types.Int) #)
  {- Arity: 2, Strictness: <L,1*U(U,U,U,1*U,A,A)><L,U(U)>,
     Inline: [0],
     Unfolding: (\ w :: Test.QuickCheck.Random.QCGen
                   w1 :: GHC.Types.Int ->
                 let {
                   ds1 :: (System.Random.TF.Gen.TFGen, System.Random.TF.Gen.TFGen)
                   = case w `cast`
                          (Test.QuickCheck.Random.NTCo:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8, ww9) } }
                 } in
                 (# Test.QuickCheck.Gen.listOf2
                      @ GHC.Types.Char
                      Generadores.genLetra
                      (case ds1 of wild { (,) g1 g2 ->
                       g1 `cast` (Sym (Test.QuickCheck.Random.NTCo:QCGen[0])) })
                      w1,
                    let {
                      ds2 :: (System.Random.TF.Gen.TFGen, System.Random.TF.Gen.TFGen)
                      = case ds1 of wild { (,) g1 g2 ->
                        case g2 of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                        case System.Random.TF.Gen.$wtfGenSplit
                               ww1
                               ww2
                               ww3
                               ww4 of ww7 { (#,#) ww8 ww9 ->
                        (ww8, ww9) } } }
                    } in
                    (case w1 of ww { GHC.Types.I# ww1 ->
                     Test.QuickCheck.Gen.$wa3
                       @ GHC.Types.Int
                       Afin.mensajeYclaveA4
                         `cast`
                       (Sym (Test.QuickCheck.Gen.NTCo:Gen[0] <GHC.Types.Int>_R))
                       Afin.primocon26
                       (case ds2 of wild { (,) g1 g2 ->
                        g1 `cast` (Sym (Test.QuickCheck.Random.NTCo:QCGen[0])) })
                       ww1 },
                     case System.Random.$wrandomIvalInteger
                            @ Test.QuickCheck.Random.QCGen
                            @ GHC.Types.Int
                            Test.QuickCheck.Random.$fRandomGenQCGen
                            GHC.Num.$fNumInt
                            Afin.mensajeYclaveA3
                            Afin.mensajeYclaveA2
                            (case ds2 of wild { (,) g1 g2 ->
                             case g2 of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                             case System.Random.TF.Gen.$wtfGenSplit
                                    ww1
                                    ww2
                                    ww3
                                    ww4 of ww7 { (#,#) ww8 ww9 ->
                             ww8
                               `cast`
                             (Sym (Test.QuickCheck.Random.NTCo:QCGen[0])) } } }) of ww2 { (#,#) ww3 ww4 ->
                     ww3 }) #)) -}
fd8b07a82ccfdb988a45337c693aece8
  $wa1 :: Test.QuickCheck.Random.QCGen -> GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w :: Test.QuickCheck.Random.QCGen ->
                 case System.Random.$wrandomIvalInteger
                        @ Test.QuickCheck.Random.QCGen
                        @ GHC.Types.Int
                        Test.QuickCheck.Random.$fRandomGenQCGen
                        GHC.Num.$fNumInt
                        Afin.mensajeYclaveA3
                        Afin.mensajeYclaveA2
                        w of ww2 { (#,#) ww3 ww4 ->
                 ww3 }) -}
1a357289f5b0f20b842c4b0accf6f699
  $wafinF ::
    GHC.Types.Int
    -> GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(U)><L,U(U)><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Types.Int
                   ww1 :: GHC.Types.Int
                   w :: GHC.Base.String ->
                 letrec {
                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Char] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            (case y of wild1 { GHC.Types.C# c# ->
                             case ww of wild2 { GHC.Types.I# y1 ->
                             case ww1 of wild3 { GHC.Types.I# y2 ->
                             case GHC.Classes.modInt#
                                    (GHC.Prim.+#
                                       (GHC.Prim.*# (GHC.Prim.-# (GHC.Prim.ord# c#) 65) y1)
                                       y2)
                                    26 of ww2 { DEFAULT ->
                             let {
                               i# :: GHC.Prim.Int# = GHC.Prim.+# ww2 65
                             } in
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.leWord#
                                       (GHC.Prim.int2Word# i#)
                                       __word 1114111) of wild4 {
                               GHC.Types.False -> GHC.Char.chr2 i#
                               GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# i#) } } } } })
                            (go ys) }
                 } in
                 go w) -}
d92f3e9ec7a433ed94ecf7b63d09529e
  $wafinG ::
    GHC.Types.Int
    -> GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U(U)><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Types.Int
                   ww1 :: GHC.Types.Int
                   w :: GHC.Base.String ->
                 let {
                   lvl10 :: GHC.Types.Int
                   = Asociacion1.invMod
                       @ GHC.Types.Int
                       GHC.Real.$fIntegralInt
                       ww
                       Afin.afinG1
                 } in
                 letrec {
                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Char] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> GHC.Types.:
                            @ GHC.Types.Char
                            (case y of wild1 { GHC.Types.C# c# ->
                             case ww1 of wild2 { GHC.Types.I# y1 ->
                             case lvl10 of wild3 { GHC.Types.I# y2 ->
                             case GHC.Classes.modInt#
                                    (GHC.Prim.*#
                                       (GHC.Prim.-# (GHC.Prim.-# (GHC.Prim.ord# c#) 65) y1)
                                       y2)
                                    26 of ww2 { DEFAULT ->
                             let {
                               i# :: GHC.Prim.Int# = GHC.Prim.+# ww2 65
                             } in
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.leWord#
                                       (GHC.Prim.int2Word# i#)
                                       __word 1114111) of wild4 {
                               GHC.Types.False -> GHC.Char.chr2 i#
                               GHC.Types.True -> GHC.Types.C# (GHC.Prim.chr# i#) } } } } })
                            (go ys) }
                 } in
                 go w) -}
d085135bb4afc3505ed225a3b93d7f5f
  $wgo ::
    [(GHC.Types.Int, GHC.Types.Char)]
    -> GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: [0] -}
4fa9f5b69d2b0aa972498fde0fa04871
  $wmensajeYclaveOK ::
    GHC.Base.String -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String ww1 :: GHC.Types.Int ->
                 case ww of wild {
                   [] -> GHC.Types.False
                   : ipv ipv1
                   -> case (Asociacion1.enAbecedario_go wild)
                             `cast`
                           (Data.Monoid.NTCo:All[0]) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> Afin.primocon26 ww1 } }) -}
8adfbd7421a80c54a039aa78efe2e9ae
  $wposibleClave ::
    GHC.Base.String -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w :: GHC.Base.String ->
                 let {
                   ds :: (GHC.Types.Int, GHC.Types.Int)
                   = case GHC.Base.map
                            @ GHC.Types.Char
                            @ GHC.Types.Int
                            Asociacion1.char2int
                            (Afin.$wgo
                               (Data.OldList.sortBy
                                  @ (GHC.Types.Int, GHC.Types.Char)
                                  Criptoanalisis.ordena1
                                  (Criptoanalisis.frecuencias w))
                               2) of wild {
                       [] -> Afin.posibleClave1
                       : x ds1
                       -> case ds1 of wild1 {
                            [] -> Afin.posibleClave1
                            : y ds2
                            -> case ds2 of wild2 {
                                 [] -> (x, y) : ipv ipv1 -> Afin.posibleClave1 } } }
                 } in
                 let {
                   y :: GHC.Types.Int = case ds of ds1 { (,) x y1 -> y1 }
                 } in
                 (# Afin.despejak1 (case ds of ds1 { (,) x y1 -> x }) y, y #)) -}
5c4f1ee64332cec18453fa0e18cfe892
  afinF ::
    (GHC.Types.Int, GHC.Types.Int)
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U(U(U),U(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (GHC.Types.Int, GHC.Types.Int) w1 :: GHC.Base.String ->
                 case w of ww { (,) ww1 ww2 -> Afin.$wafinF ww1 ww2 w1 }) -}
33695a8a5e4d95a8ad8be831051cfdfb
  afinG ::
    (GHC.Types.Int, GHC.Types.Int)
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U(U,U(U))><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (GHC.Types.Int, GHC.Types.Int) w1 :: GHC.Base.String ->
                 case w of ww { (,) ww1 ww2 -> Afin.$wafinG ww1 ww2 w1 }) -}
6c6e2b693b62f4febdaab4b4db78c693
  afinG1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 26) -}
cc6de776947562979e5bc62d4549f700
  desencriptaAfin :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ m :: GHC.Base.String -> Afin.afinG (Afin.posibleClave m) m) -}
c7fd03ba2f67167c32ebc28ecb5e707c
  despejak1 :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U(U)>,
     Unfolding: (\ x :: GHC.Types.Int y :: GHC.Types.Int ->
                 Asociacion1.invMod
                   @ GHC.Types.Int
                   GHC.Real.$fIntegralInt
                   (case x of wild { GHC.Types.I# x1 ->
                    case y of wild1 { GHC.Types.I# y1 ->
                    let {
                      a :: GHC.Prim.Int# = GHC.Prim.-# x1 y1
                    } in
                    letrec {
                      $wgo1 :: [GHC.Types.Int] -> GHC.Prim.Int#
                        {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                      = \ w :: [GHC.Types.Int] ->
                        case w of wild2 {
                          [] -> case GHC.List.badHead ret_ty GHC.Prim.Int# of {}
                          : y2 ys
                          -> case y2 of wild3 { GHC.Types.I# x2 ->
                             case GHC.Classes.modInt# (GHC.Prim.*# x2 a) 26 of ww2 {
                               DEFAULT -> $wgo1 ys
                               4
                               -> let {
                                    nsign :: GHC.Prim.Int# = GHC.Prim.uncheckedIShiftRA# x2 63
                                  } in
                                  case {__pkg_ccall integer-gmp-1.0.0.0 integer_gmp_gcd_word GHC.Prim.Word#
                                                                                             -> GHC.Prim.Word#
                                                                                             -> GHC.Prim.State#
                                                                                                  GHC.Prim.RealWorld
                                                                                             -> (# GHC.Prim.State#
                                                                                                     GHC.Prim.RealWorld,
                                                                                                   GHC.Prim.Word# #)}
                                         (GHC.Prim.int2Word#
                                            (GHC.Prim.-# (GHC.Prim.xorI# x2 nsign) nsign))
                                         __word 26
                                         GHC.Prim.realWorld# of wild4 { (#,#) ds2 ds3 ->
                                  case GHC.Prim.word2Int# ds3 of wild5 {
                                    DEFAULT -> $wgo1 ys 1 -> x2 } } } } }
                    } in
                    case $wgo1 Afin.despejak2 of ww { DEFAULT -> GHC.Types.I# ww } } })
                   Afin.afinG1) -}
a5f30d28a81d237b8de2910f0dd5e47c
  despejak2 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 1 25) -}
0a7e38c07b5cfb16e912117a82553e38
  letrasFrecuentes :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ m :: GHC.Base.String ->
                 Afin.$wgo
                   (Data.OldList.sortBy
                      @ (GHC.Types.Int, GHC.Types.Char)
                      Criptoanalisis.ordena1
                      (Criptoanalisis.frecuencias m))
                   2) -}
6fe31da86c2bf009bc2fa08363865949
  mensajeYclaveA ::
    Test.QuickCheck.Gen.Gen
      (GHC.Base.String, (GHC.Types.Int, GHC.Types.Int))
  {- Arity: 2, Strictness: <L,1*U(U,U,U,1*U,A,A)><L,U(U)>m,
     Unfolding: InlineRule (0, True, True)
                Afin.mensajeYclaveA1
                  `cast`
                (Sym (Test.QuickCheck.Gen.NTCo:Gen[0]
                          <(GHC.Base.String, (GHC.Types.Int, GHC.Types.Int))>_R)) -}
7e92c90ebce3cf8fa662e5ebe51f0629
  mensajeYclaveA1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> (GHC.Base.String, (GHC.Types.Int, GHC.Types.Int))
  {- Arity: 2, Strictness: <L,1*U(U,U,U,1*U,A,A)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Test.QuickCheck.Random.QCGen w1 :: GHC.Types.Int ->
                 case Afin.$wa w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
65e4470edd8efb4050dfca3e9b1b3113
  mensajeYclaveA2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 26) -}
59ae8fb195612396749f9dbc343b552e
  mensajeYclaveA3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
c08cb11520428bd3ca9a867c1b56bab5
  mensajeYclaveA4 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <L,U><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ w :: Test.QuickCheck.Random.QCGen w1 :: GHC.Types.Int ->
                 Afin.$wa1 w) -}
369409034827594ec9f51addcbced51c
  mensajeYclaveOK ::
    (GHC.Base.String, (GHC.Types.Int, GHC.Types.Int)) -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U(1*U(U),A))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (GHC.Base.String, (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { (,) ww4 ww5 ->
                 Afin.$wmensajeYclaveOK ww1 ww4 } }) -}
e866d408a7b8b5550949401139632fcb
  posibleClave :: GHC.Base.String -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 case Afin.$wposibleClave w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
6a986e520ae3ed3fe72fc439a2f2d80b
  posibleClave1 :: (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: b -}
71bba59448f5b24df079ca5f20217c0a
  primocon26 :: GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ n :: GHC.Types.Int ->
                 case n of wild { GHC.Types.I# x ->
                 let {
                   nsign :: GHC.Prim.Int# = GHC.Prim.uncheckedIShiftRA# x 63
                 } in
                 case {__pkg_ccall integer-gmp-1.0.0.0 integer_gmp_gcd_word GHC.Prim.Word#
                                                                            -> GHC.Prim.Word#
                                                                            -> GHC.Prim.State#
                                                                                 GHC.Prim.RealWorld
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  GHC.Prim.Word# #)}
                        (GHC.Prim.int2Word# (GHC.Prim.-# (GHC.Prim.xorI# x nsign) nsign))
                        __word 26
                        GHC.Prim.realWorld# of wild2 { (#,#) ds2 ds3 ->
                 case GHC.Prim.word2Int# ds3 of wild1 {
                   DEFAULT -> GHC.Types.False 1 -> GHC.Types.True } } }) -}
3bf9aaf3d9d4f6ba0009a74aa96e0cd4
  prop_CorreccionAfin :: Test.QuickCheck.Property.Property
  {- Arity: 2, Strictness: <L,1*U(U,U,U,1*U,A,A)><L,U(U)>,
     Unfolding: InlineRule (0, True, True)
                Afin.prop_CorreccionAfin1
                  `cast`
                (Trans
                     (Sym (Test.QuickCheck.Gen.NTCo:Gen[0]
                               <Test.QuickCheck.Property.Prop>_R))
                     (Sym (Test.QuickCheck.Property.NTCo:Property[0]))) -}
a2f762d7eb53da06dc317349b622b0eb
  prop_CorreccionAfin1 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Test.QuickCheck.Property.Prop
  {- Arity: 2, Strictness: <L,1*U(U,U,U,1*U,A,A)><L,U(U)>,
     Unfolding: (\ eta :: Test.QuickCheck.Random.QCGen
                   eta1 :: GHC.Types.Int ->
                 let {
                   ds1 :: (System.Random.TF.Gen.TFGen, System.Random.TF.Gen.TFGen)
                   = case eta
                            `cast`
                          (Test.QuickCheck.Random.NTCo:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                     case System.Random.TF.Gen.$wtfGenSplit
                            ww1
                            ww2
                            ww3
                            ww4 of ww7 { (#,#) ww8 ww9 ->
                     (ww8, ww9) } }
                 } in
                 let {
                   x :: (GHC.Base.String, (GHC.Types.Int, GHC.Types.Int))
                   = case Afin.$wa
                            (case ds1 of wild { (,) g1 g2 ->
                             g1 `cast` (Sym (Test.QuickCheck.Random.NTCo:QCGen[0])) })
                            eta1 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 (Test.QuickCheck.Property.counterexample_$scounterexample1
                    (case x of ww { (,) ww1 ww2 ->
                     GHC.Types.:
                       @ GHC.Types.Char
                       GHC.Show.shows9
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.shows6
                          (GHC.Show.showLitString
                             ww1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showList__1
                                   (GHC.Show.$fShow(,)_$sgo
                                      (\ w4 :: GHC.Base.String ->
                                       case ww2 of ww4 { (,) ww5 ww6 ->
                                       GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows9
                                         (case ww5 of ww7 { GHC.Types.I# ww3 ->
                                          case GHC.Show.$wshowSignedInt
                                                 0
                                                 ww3
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.showList__1
                                                    (GHC.Show.$fShow(,)_$sgo
                                                       (\ w2 :: GHC.Base.String ->
                                                        case ww6 of ww8 { GHC.Types.I# ww9 ->
                                                        case GHC.Show.$wshowSignedInt
                                                               0
                                                               ww9
                                                               w2 of ww10 { (#,#) ww11 ww12 ->
                                                        GHC.Types.: @ GHC.Types.Char ww11 ww12 } })
                                                       (GHC.Types.[] @ GHC.Show.ShowS)
                                                       (GHC.Types.:
                                                          @ GHC.Types.Char
                                                          GHC.Show.shows8
                                                          w4))) of ww8 { (#,#) ww9 ww10 ->
                                          GHC.Types.: @ GHC.Types.Char ww9 ww10 } }) })
                                      (GHC.Types.[] @ GHC.Show.ShowS)
                                      Afin.prop_CorreccionAfin2))))) })
                    (case x of wild { (,) m k ->
                     case k of ww { (,) ww1 ww2 ->
                     GHC.Base.eqString
                       m
                       (Afin.$wafinG ww1 ww2 (Afin.$wafinF ww1 ww2 m)) } }))
                   `cast`
                 (Trans
                      (Test.QuickCheck.Property.NTCo:Property[0])
                      (Test.QuickCheck.Gen.NTCo:Gen[0]
                           <Test.QuickCheck.Property.Prop>_R))
                   (case ds1 of wild { (,) g1 g2 ->
                    g2 `cast` (Sym (Test.QuickCheck.Random.NTCo:QCGen[0])) })
                   eta1) -}
106c43c518c034affd0d231edb9d7eaf
  prop_CorreccionAfin2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows8
                   (GHC.Types.[] @ GHC.Types.Char)) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

